# 대용량 데이터, 어떻게 처리하고 계신가요?

## 들어가며

정보가 늘어나면서 데이터를 효율적으로 다루는 일이 정말 중요해졌다. 특히 실무에서는 대용량 데이터를 단순히 저장하고 조회하는 것만으로는 한계를 느끼는 순간이 있다. 이 글에서는 대용량 데이터 처리 시 고려할 핵심 요소와 이를 해결하기 위한 접근법을 정리하고자 한다.

## 문제점

"왜 이렇게 느려?" 🤯 데이터 수집과 적재 시 성능 관점에서 살펴보자.

## 대용량 데이터를 다룰 때 고려해야 할 요소

### 1. 병목 확인

우선 처리 시간이 오래 걸리는 병목 구간부터 확인해야 한다. 대용량 처리에서는 예상치 못한 곳에서 지연이 발생하는 경우가 많다. 정확한 병목 지점을 파악하는 것이 가장 중요하다. Java에서는 상황에 따라 다양한 방식으로 코드 실행 시간을 측정할 수 있다.

**1. System.currentTimeMillis()**

Java에서 기본적으로 제공하는 메서드로, 현재 시간을 밀리세컨드 단위로 출력할 수 있다. 특정 부분에 대한 실행 시간을 간단하게 확인하고 싶을 때 사용하면 좋다.

```java
public void measureExecutionTime {
    long startTime = System.currentTimeMillis();
    // 실행할 코드
    long endTime = System.currentTimeMillis();
    System.out.println("실행 시간: " + (endTime - startTime) + "ms");
}
```

**2. StopWatch**

Spring에서 제공해주는 클래스로, 여러 작업에 대한 소요시간을 측정해준다. 그래서 병목이 의심되는 구간이 많을 때 사용하기 좋다. 전체 처리 과정 중 어떤 작업이 대부분의 비율을 차지하는지, 처음 보는 사람도 오래 걸리는 지점을 명확하게 파악할 수 있다.

```java
public void measureExecutionTime {
    StopWatch stopWatch = new StopWatch();
    stopWatch.start("Task 1");
    // 첫 번째 작업 실행
    stopWatch.stop();
    stopWatch.start("Task 2");
    // 두 번째 작업 실행
    stopWatch.stop();
    System.out.println(stopWatch.prettyPrint()); // 결과 출력
}

// 결과
StopWatch '': running time (millis) = 1502
-----------------------------------------
ms     %     Task name
-----------------------------------------
0501  33%  Task 1
1001  67%  Task 2
```

### 2. 애플리케이션 레벨

**1. 비동기 및 병렬 처리**

Spring를 포함한 많은 프레임워크에서 동기적 실행 방식을 기본으로 합니다. 동기 방식은 코드가 위에서 아래로 실행되어 직관적이고 예측 가능하다는 장점이 있지만, 하나의 작업이 끝날 때까지 다음 작업이 대기해야하기 때문에 병목의 원인이 될 수 있습니다.

그래서 대용량 데이터에서는 비동기를 적절하게 활용하는 것이 중요하더라구요. 특히 I/O 작업이 많거나 응답 시간이 필요한 경우에 성능을 극대화할 수 있는데요. 예를 들어, 파일이나 API 호출을 비동기로 병렬적으로 처리한다면 응답 대기 없이 다음 작업을 처리하기 때문에 CPU 리소스를 효율적으로 활용할 수 있습니다.

저같은 경우, 반복적으로 수백건의 API를 한번에 요청해 데이터를 수집해야하는 경우가 있었는데요. 동기적으로 처리하는 경우 모든 대기시간의 총합을 오롯이 기다려야 했겠지만, 비동기를 적용하여 대기 없이 요청을 병렬로 보내 성능을 개선했던 경험이 있습니다. 데이터 수집이다보니 가공 전에 blocking이 필요하지만 요청을 한번에 보내고 대기시간이 짧아진다는 측면에서 유의미한 성능개선을 할 수 있었습니다. (응답 서버의 응답 방식에 따라 유/무의미할 수 있습니다.)

![](https://velog.velcdn.com/images/sa46lll/post/5b65fa34-8843-445d-865e-3f1d4d45256f/image.png)

비동기 실행 방식이 항상 효율적인건 아닙니다. 상황에 따라 오히려 자원 낭비가 발생할 수 있고, I/O 대기시간을 줄이는 것이지, CPU 연산 자체를 줄이는 것이 아니라서 연산에 적용할 경우 스레드 컨텍스트 스위칭 비용만 발생하여 느려질 수 있으니 적절하게 사용하는 것이 좋습니다.

**2. 스레드 관리**

여러 개의 스레드를 사용하면 병렬로 작업을 나눠 더 빠르게 처리할 수 있습니다. CPU 코어를 효율적으로 활용해서 리소스를 최적화할 수 있는데요.

**주의** 스레드를 많이 쓴다고 성능이 좋아지는 것은 아님 너무 많이 생성하면 스레드 컨텍스트 스위칭 비용이 커지고, 메모리 부족 문제 발생

**그래서 스레드 개수 어떻게?**

적정 스레드 개수 = cpu 코어 개수 \* (1+대기시간/서비스시간)

* CPU 코어 개수: 물리적으로 사용할 수 있는 CPU 개수
* 대기시간: I/O 대기 등 CPU를 사용하지 않는 시간
* 서비스시간: CPU가 실제로 연산하는 시간

> **그래서 얼마로 설정하는데!**

1. CPU 연산이 많은 서비스 (서비스시간 ≫ 대기시간) → 적정 스레드 개수 ≈ CPU 코어 개수 → 예: 머신러닝 연산, 이미지 처리, 비디오 인코딩
2. I/O 대기 시간이 긴 서비스 (대기시간 ≫ 서비스시간) → 적정 스레드 개수 > CPU 코어 개수 (더 많은 스레드 활용 가능) → 예: REST API 서버, 데이터베이스 쿼리, 외부 API 호출

> **예시** CPU 8코어 서버

* CPU 연산이 많다 → 코어 개수 수준으로 제한 (예: 8\~16개)
* I/O 대기 시간이 길다 → 공식에 따라 2\~10배까지 늘려도 OK
* 너무 많으면 컨텍스트 스위칭 비용이 커지므로 적절한 값 튜닝 필요 **(from ChatGPT)**



3. **가상 스레드 / ParallelStream**

Java 19+에서 도입된 경량(가벼운) 스레드로, 기존 OS 기반의 플랫폼 스레드보다 훨씬 많은 동시 작업을 처리할 수 있는 기술입니다.



4. **캐싱**

사용자에게 동일한 결과를 위해 자주 조회되거나 조회에 대한 연산 비용이 드는 경우에 사용하면 좋습니다.



### 3. 데이터베이스

**1. 인덱스**

**2. 쿼리 최적화**

bulk insert/update 사용

**3. NoSQL, Elasticsearch**

✅ NoSQL → 대량 데이터 저장 & 빠른 조회에 적합

✅ Elasticsearch → 초고속 검색 & 실시간 데이터 분석 최적화

NoSQL가 빠른 이유?

* 정해진 스키마가 없어서 insert/update가 빠름
* 트랜잭션 관리와 ACID 보장이 느슨해서 빠름
* 정규화 x

NoSQL 저장 방식 (Document, Key-Value 등)

* 데이터를 한 곳(Document) 안에 중첩(Nested) 형태로 저장 → JOIN 없이 빠르게 조회 가능
* 스키마가 유연함 (Schema-less) → 컬럼을 미리 정의할 필요 없음
* 샤딩(Sharding)과 복제(Replication) 구조로 수평 확장 가능



### 4. 인프라

1. 스케일 업

CPU, RAM, Disk 성능 업그레이드

1. 스케일 아웃

여러대의 서버를 추가하여 부하를 분산 (과거 데이터 적재할 경우)

## 마무리

